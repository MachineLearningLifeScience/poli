"""
In this script, we test whether POLi can
optimize the stability of a protein using
FoldX as an objective function.

By this, I mean: I'm not exactly sure whether
the conda environment will be enough to run
FoldX. If not, we'll have to use a Docker
container.
"""
from pathlib import Path
from typing import List, TypedDict, Tuple
import subprocess
import shutil
from time import time
from uuid import uuid4
import logging

import numpy as np

from Bio import PDB
from Bio.SeqUtils import seq1

from foldx_utils import AMINO_ACIDS, MAX_SEQUENCE_LENGTH

from poli.core.abstract_black_box import AbstractBlackBox
from poli.core.abstract_problem_factory import AbstractProblemFactory
from poli.core.problem_setup_information import ProblemSetupInformation

THIS_DIR = Path(__file__).parent.resolve()
PATH_TO_FOLDX_FILES = Path().home() / "foldx"

# This is the folder where all the files
# generated by FoldX will be stored.
# Feel free to change it if you want
# to keep the files somewhere else.
# An alternative is e.g. TMP_PATH = THIS_DIR
TMP_PATH = Path("/tmp").resolve()


class FoldXContext(TypedDict):
    pdb_files: List[Path]
    delete_working_dir: bool


class FoldXStabilityBlackBox(AbstractBlackBox):
    def __init__(self, L: int):
        super().__init__(L)
        self.parser = PDB.PDBParser(QUIET=True)

    def create_working_directory(self, watermark: str = None) -> Path:
        """
        TODO: document.
        """
        if watermark is None:
            watermark = f"{int(time())}_{str(uuid4())[:8]}"

        working_dir = TMP_PATH / "foldx_tmp_files" / watermark
        working_dir.mkdir(exist_ok=True, parents=True)

        return working_dir

    def _black_box(self, x: np.ndarray, context: FoldXContext) -> np.ndarray:
        """
        Runs the given input x and pdb files provided
        in the context through FoldX and returns the
        total energy score.
        """
        # Check if the context is valid
        pdb_files = context["pdb_files"]
        delete_working_dir = context["delete_working_dir"]

        assert len(pdb_files) == len(
            x
        ), "The number of pdb files in the context must match the number of inputs."

        # Create a working directory for this function call
        working_dir = self.create_working_directory()

        # Process each file in the context
        results = []
        for i, pdb_file in enumerate(pdb_files):
            working_dir_at_i = working_dir / f"{pdb_file.stem}_{i}"
            working_dir_at_i.mkdir(exist_ok=True, parents=True)
            shutil.copyfile(
                PATH_TO_FOLDX_FILES / "rotabase.txt", working_dir_at_i / "rotabase.txt"
            )

            # Copy the pdb file to the working directory
            pdb_name = f"{pdb_file.stem}_{i}"
            shutil.copyfile(pdb_file, working_dir_at_i / f"{pdb_name}.pdb")

            # Reading the pdb file and defining a mutation
            # to itself on the first residue
            residues = self.parser.get_structure("pdb", pdb_file).get_residues()
            first_residue = next(residues)
            residue_name = seq1(first_residue.get_resname())
            chain_id = first_residue.get_parent().id
            index_in_sequence = first_residue.id[1]

            # Creating a dummy individual list of mutations
            with open(working_dir_at_i / "individual_list.txt", "w") as f:
                f.write(f"{residue_name}{chain_id}{index_in_sequence}{residue_name};\n")

            # Run FoldX
            logging.debug(f"Running FoldX for file {pdb_file}...")
            subprocess.run(
                [
                    "foldx",
                    "--command",
                    "BuildModel",
                    "--pdb",
                    f"{pdb_name}.pdb",
                    "--mutant-file",
                    f"{str(working_dir_at_i / 'individual_list.txt')}",
                    "--water",
                    "-CRYSTAL",
                    "--pH",
                    "7.0",
                ],
                cwd=working_dir_at_i,
            )

            # Read the output files
            with open(working_dir_at_i / f"Raw_{pdb_name}.fxout", "r") as f:
                lines = f.readlines()
                result = lines[-1].split()[1]

            results.append(float(result))

        # Delete the working directory
        if delete_working_dir:
            shutil.rmtree(working_dir)

        return np.array(results).reshape(-1, 1)


class FoldXStabilityProblemFactory(AbstractProblemFactory):
    def get_setup_information(self) -> ProblemSetupInformation:
        """
        TODO: document
        """
        alphabet_symbols = AMINO_ACIDS
        alphabet = {symbol: i for i, symbol in enumerate(alphabet_symbols)}

        return ProblemSetupInformation(
            name="FoldX_stability",
            max_sequence_length=MAX_SEQUENCE_LENGTH,
            alphabet=alphabet,
            aligned=True,
        )

    def create(
        self, seed: int = 0, initial_pdb_file: Path = None
    ) -> Tuple[AbstractBlackBox, np.ndarray, np.ndarray]:
        L = self.get_setup_information().get_max_sequence_length()
        f = FoldXStabilityBlackBox(L)

        # TODO: this should be the initial sequence
        x0 = np.random.randint(0, len(AMINO_ACIDS), size=L).reshape(1, -1)
        if initial_pdb_file is None:
            initial_pdb_file = THIS_DIR / "101m_Repair.pdb"

        pdb_files = [initial_pdb_file]

        f_0 = f(x0, {"pdb_files": pdb_files, "delete_working_dir": False})

        return f, x0, f_0


if __name__ == "__main__":
    from poli import objective_factory
    from poli.core.registry import register_problem

    # (once) we have to register our factory
    foldx_stability_problem_factory = FoldXStabilityProblemFactory()
    register_problem(
        foldx_stability_problem_factory,
        conda_environment_location="/Users/migd/anaconda3/envs/poli-dev",
    )

    # now we can instantiate our objective
    problem_name = (
        foldx_stability_problem_factory.get_setup_information().get_problem_name()
    )
    problem_info, f, x0, y0, run_info = objective_factory.create(
        problem_name, caller_info=None, observer=None
    )

    initial_pdb_file = THIS_DIR / "101m_Repair.pdb"

    print(f(x0, context={"pdb_files": [initial_pdb_file], "delete_working_dir": False}))
    f.terminate()
